<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="Github 项目地址

一、Netty 是什么
Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github 上的独立项目。Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。
也就是说，Netty 是一个基于 NIO">
    

    <!--Author-->
    
        <meta name="author" content="Liangxj">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Netty介绍"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Liangxj"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>Netty介绍 - Liangxj</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/main.css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!--Favicon-->
    

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Liangxj" type="application/atom+xml">
</head>

<body>

<!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">Liangxj</a>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives">Archives</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class="social clearfix">
            
            
                <li><a href="https://www.facebook.com/" class="fb" target="_blank" data-title="Facebook"></a></li>
            
            
                <li><a href="https://www.behance.net/" class="behance" target="_blank" data-title="Behance"></a></li>
            
            
                <li><a href="https://plus.google.com/+Pixelhint/posts" class="google" target="_blank" data-title="Google+"></a></li>
            
            
                <li><a href="https://dribbble.com/pixelhint" class="dribble" target="_blank" data-title="Dribble"></a></li>
            
            
            
            
        </ul><!-- end social -->

        <div class="rights">
            <p>Copyright © 2014 magnetic.</p>
            <p>Template by <a target="_blank" rel="noopener" href="http://pixelhint.com/magnetic-free-html5-responsive-photography-website-template/">Pixelhint.com</a></p>
            <p>Hexo Theme by <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan K.</a></p>
        </div><!-- end rights -->
    </div ><!-- end footer -->
</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('http://placehold.it/1300x500');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a href="/blog/4a17b156.html" class="previous" data-title="Hello World"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/blog/5cdb78f2.html" class="next" data-title="日语学习"></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">Netty介绍</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/netty/netty">Github 项目地址</a></p>
</blockquote>
<h1 id="一、Netty-是什么"><a href="#一、Netty-是什么" class="headerlink" title="一、Netty 是什么"></a>一、Netty 是什么</h1><p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/aa911f591044.png" alt="Netty"></p>
<p>Netty 是由 JBOSS 提供的一个 <strong>Java 开源框架</strong>，现为 Github 上的独立项目。Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
<p>也就是说，Netty 是一个<strong>基于 NIO 的客户、服务器端的编程框架</strong>，使用 Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户、服务端应用。Netty 相当于简化和流线化了网络应用的编程开发过程，例如：基于 TCP 和 UDP 的 Socket 服务开发。</p>
<p>“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议（包括 FTP、SMTP、HTTP 等各种二进制文本协议）的实现经验，并经过相当精心设计的项目。最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。</p>
<h1 id="二、BIO-和-NIO-和-AIO"><a href="#二、BIO-和-NIO-和-AIO" class="headerlink" title="二、BIO 和 NIO 和 AIO"></a>二、BIO 和 NIO 和 AIO</h1><blockquote>
<p>摘录自博客：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903985158045703">如何理解BIO、NIO、AIO的区别？ - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/386745556">这是我看过对bio，nio，aio解释的最透彻的文章！！！ - 知乎 (zhihu.com)</a></p>
</blockquote>
<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/v2-f49145ba3048ff5fe749353d1710e65b_1440w.jpg" alt="BIO、NIO、AIO"></p>
<h2 id="2-1-Java-中的-IO-原理"><a href="#2-1-Java-中的-IO-原理" class="headerlink" title="2.1 Java 中的 IO 原理"></a>2.1 Java 中的 IO 原理</h2><p>首先 Java 中的 IO 都是依赖操作系统内核进行的，我们程序中的 IO 读写其实调用的是操作系统内核中的 read&amp;write 两大系统调用。</p>
<p>那内核是如何进行 IO 交互的呢？</p>
<ol>
<li>网卡收到经过网线传来的网络数据，并将网络数据写到内存中。</li>
<li>当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</li>
<li>将内存中的网络数据写入到对应 socket 的接收缓冲区中。</li>
<li>当接收缓冲区的数据写好之后，应用程序开始进行数据处理。</li>
</ol>
<p>对应抽象到 Java 的 socket 代码简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//获取数据进行处理</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// socket、server，流关闭操作，省略不表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个过程和底层内核的网络 IO 很类似，主要体现在 accept() 等待从网络中的请求到来然后 bytes[] 数组作为缓冲区等待数据填满后进行处理。而 BIO、NIO、AIO 之间的区别就在于这些操作是同步还是异步，阻塞还是非阻塞。</p>
<p>所以我们引出同步异步，阻塞与非阻塞的概念。</p>
<h2 id="2-2-同步与异步"><a href="#2-2-同步与异步" class="headerlink" title="2.2 同步与异步"></a>2.2 同步与异步</h2><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们的执行流程中：依次是方法一和方法二。</p>
<p>同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。</p>
<p>异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。</p>
<p>同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/452184164/answer/1930227093">同步与异步</a>是从多个线程之间的协调来实现效率差异。</p>
<blockquote>
<p>为什么需要异步呢？笔者认为异步的本质就是为了解决主线程的阻塞，所以网上很多讨论把同步异步、阻塞非阻塞进行了四种组合，其中一种就有异步阻塞这一情形，如果异步也是阻塞的？那为什么要特地进行异步操作呢？</p>
</blockquote>
<h2 id="2-3-阻塞与非阻塞"><a href="#2-3-阻塞与非阻塞" class="headerlink" title="2.3 阻塞与非阻塞"></a>2.3 阻塞与非阻塞</h2><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p>
<p>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</p>
<p>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔段时间再来观察同步方法是否完成。</p>
<p>阻塞与非阻塞关注的是线程是否在原地等待。</p>
<blockquote>
<p>笔者认为阻塞和非阻塞仅能与同步进行组合。而异步天然就是非阻塞的，而这个非阻塞是对主线程而言。（可能有人认为异步方法里面放入阻塞操作的话就是异步阻塞，但是思考一下，正是因为是阻塞操作所以才会将它放入异步方法中，不要阻塞主线程）</p>
</blockquote>
<h2 id="2-4-例子讲解"><a href="#2-4-例子讲解" class="headerlink" title="2.4 例子讲解"></a>2.4 例子讲解</h2><blockquote>
<p>海底捞很好吃，但是经常要排队。我们就以生活中的这个例子进行讲解。</p>
</blockquote>
<ul>
<li>A 顾客去吃海底捞，就这样干坐着等了一小时，然后才开始吃火锅。(BIO)</li>
<li>B 顾客去吃海底捞，他一看要等挺久，于是去逛商场，每次逛一会就跑回来看有没有排到他。于是他最后既购了物，又吃上海底捞了。（NIO）</li>
<li>C 顾客去吃海底捞，由于他是高级会员，所以店长说，你去商场随便玩吧，等下有位置，我立马打电话给你。于是 C 顾客不用干坐着等，也不用每过一会儿就跑回来看有没有等到，最后也吃上了海底捞（AIO）</li>
</ul>
<blockquote>
<p>哪种方式更有效率呢？是不是一目了然呢？</p>
</blockquote>
<h2 id="2-5-BIO"><a href="#2-5-BIO" class="headerlink" title="2.5 BIO"></a>2.5 BIO</h2><p>BIO 全称是 Blocking IO，是 JDK1.4 之前的传统 IO 模型，本身是同步阻塞模式。线程发起 IO 请求后，一直阻塞 IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。</p>
<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/v2-2e437fe57c8df20d3a57dc18c2d0e234_r.jpg" alt="BIO 通信模型图"></p>
<h2 id="2-6-NIO"><a href="#2-6-NIO" class="headerlink" title="2.6 NIO"></a>2.6 NIO</h2><p>NIO 也叫 Non-Blocking IO 是同步非阻塞的 IO 模型。线程发起 IO 请求后，立即返回（非阻塞 IO）。同步指的是必须等待 IO 缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待 IO 缓冲区，可以先做一些其他操作，但是要定时轮询检查 IO 缓冲区数据是否就绪。</p>
<p>Java 中的 NIO 是 new IO 的意思。其实是 NIO 加上 IO 多路复用技术。普通的 NIO 是线程轮询查看一个 IO 缓冲区是否就绪，而 Java 中的 new IO 指的是线程轮询地去查看一堆 IO 缓冲区中哪些就绪，这是一种 IO 多路复用的思想。IO 多路复用模型中，将检查 IO 数据是否就绪的任务，交给系统级别的 select 或 epoll 模型，由系统进行监控，减轻用户线程负担。</p>
<p>NIO 主要有 buffer、channel、selector 三种技术的整合，通过零拷贝的 buffer 取得数据，每一个客户端通过 channel 在 selector（多路复用器）上进行注册。服务端不断轮询 channel 来获取客户端的信息。channel 上有 connect、accept（阻塞）、read（可读）、write（可写）四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的 channel。不需要新开一个线程。大大提升了性能。</p>
<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/v2-c8f57a2bab1cb068615c2c41532cdefb_r.jpg" alt="NIO 通信模型图"></p>
<blockquote>
<p>NIO 的三大核心 API：Buffer、Channel、Selector</p>
</blockquote>
<h3 id="2-6-1-Buffer（缓冲区）"><a href="#2-6-1-Buffer（缓冲区）" class="headerlink" title="2.6.1 Buffer（缓冲区）"></a>2.6.1 Buffer（缓冲区）</h3><p>IO 面向流（Stream oriented），NIO 面向缓冲区（Buffer oriented）。</p>
<p>Buffer 是一个对象，它包含一些要写入或者要读出的数据。在面向流的 I&#x2F;O 中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p>
<p>在 NIO 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="comment">// 关系: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下一个要被读写的byte元素的下标索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 缓冲区中第一个不能读写的元素的数组下标索引，也可以认为是缓冲区中实际元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="comment">// 缓冲区能够容纳元素的最大数量，这个值在缓冲区创建时被设定，而且不能够改变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">long</span> address; <span class="comment">// Used only by direct buffers，直接内存的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><p>最常用的缓冲区是 ByteBuffer，一个 ByteBuffer 提供了一组功能用于操作 byte 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">Buffer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;ByteBuffer&gt; &#123;</span><br><span class="line">    <span class="comment">// 仅限堆内内存使用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] hb;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">boolean</span> isReadOnly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuffer-API"><a href="#ByteBuffer-API" class="headerlink" title="ByteBuffer.API"></a>ByteBuffer.API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请堆外内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line"><span class="comment">// 申请堆内内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> </span><br><span class="line"><span class="comment">// 原始字节包装成ByteBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">// 原始字节包装成ByteBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span></span><br><span class="line"><span class="comment">// 创建共享此缓冲区内容的新字节缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">duplicate</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 分片，创建一个新的字节缓冲区</span></span><br><span class="line"><span class="comment">// 新ByteBuffer的开始位置是此缓冲区的当前位置position</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">slice</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 获取字节内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 从ByteBuffer偏移offset的位置，获取length长的字节数组，然后返回当前ByteBuffer对象</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">// 设置byte内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> b)</span>;</span><br><span class="line"><span class="comment">// 以offset为起始位置设置length长src的内容，并返回当前ByteBuffer对象</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="comment">// 将没有读完的数据移到到缓冲区的初始位置，position设置为最后一没读字节数据的下个索引，limit重置为为capacity</span></span><br><span class="line"><span class="comment">// 读-&gt;写模式，相当于flip的反向操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">compact</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 是否是直接内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDirect</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 转换缓冲区为写模式</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">clear</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建大小为 10 的 ByteBuffer 对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">bf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/1943529272.jpg" alt="ByteBuffer"></p>
<ol start="2">
<li>写入数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">buf.put(<span class="string">&quot;csc&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/2064948393.jpg" alt="ByteBuffer"></p>
<ol start="3">
<li>调用 flip 转换缓冲区为读模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.flip();</span><br></pre></td></tr></table></figure>

<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/L2RlZmF1bHQvaW5.jpg" alt="ByteBuffer"></p>
<ol start="4">
<li>读取缓冲区中到内容，buf.get()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="type">char</span>) buf.get());</span><br></pre></td></tr></table></figure>

<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/EwTmpOa09HRmhZVG.jpg" alt="ByteBuffer"></p>
<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/pT0RJME5qSm1Zemsw.jpg" alt="ByteBuffer"></p>
<ol start="5">
<li>调用 clear() 或 compact() 转换缓冲区为写模式，循环至步骤 1</li>
</ol>
<p>除了 ByteBuffer，还有其他的一些缓冲区，事实上，每一种 Java 基本类型（除了 Boolean 类型）都对应有一种缓冲区。</p>
<h3 id="2-6-2-Channel（通道）"><a href="#2-6-2-Channel（通道）" class="headerlink" title="2.6.2 Channel（通道）"></a>2.6.2 Channel（通道）</h3><p>NIO 通过 Channel（通道）进行读写。</p>
<p>通道是双向的，可读也可写，而流的读写是单向的。</p>
<p>无论读写，通道只能和 Buffer 交互。因为 Buffer，通道可以异步地读写。</p>
<h3 id="2-6-3-Selector（选择器）"><a href="#2-6-3-Selector（选择器）" class="headerlink" title="2.6.3 Selector（选择器）"></a>2.6.3 Selector（选择器）</h3><p>NIO 有选择器，而 IO 没有。</p>
<p>选择器满足了单个线程处理多个通道的效果，因此大大减少了线程的数量。</p>
<p>因为线程之间的切换对于操作系统来说是昂贵的（每次切换线程都要重新读取线程之前的状态、值、上下文等信息），因此选择器提高了系统的效率。</p>
<h3 id="2-6-4-原生-NIO-缺点"><a href="#2-6-4-原生-NIO-缺点" class="headerlink" title="2.6.4 原生 NIO 缺点"></a>2.6.4 原生 NIO 缺点</h3><p>然而，JDK 原生的 NIO 很难用。除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：</p>
<ul>
<li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 BUG 会导致 CPU 飙升 100%</li>
<li>项目庞大后，自行实现的 NIO 很容易出现各类 BUG，维护成本较高</li>
</ul>
<p><strong>Netty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。</strong></p>
<h2 id="2-7-AIO"><a href="#2-7-AIO" class="headerlink" title="2.7 AIO"></a>2.7 AIO</h2><p>AIO 是真正意义上的异步非阻塞 IO 模型。上述 NIO 实现中，需要用户线程定时轮询，去检查 IO 缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些 IO 就绪。而真正的理想的异步非阻塞 IO 应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。</p>
<p><img src="http://localhost:4000/assets/Netty%E4%BB%8B%E7%BB%8D/v2-5ccdc3d77174498be63efffc0e4f7783_r.jpg"></p>
<p>AIO 可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步 IO 的操作系统非常少，目前也就 windows 是 IOCP 技术实现了，而在 Linux 上，底层还是是使用的 epoll 实现的。</p>
<p>与 NIO 不同，当进行读写操作时，只需直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为， read&#x2F;write 方法都是异步的，完成后会主动调用回调函数。 在 JDK1.7 中，这部分内容成为 AIO。</p>
<h2 id="2-8-适用场景分析"><a href="#2-8-适用场景分析" class="headerlink" title="2.8 适用场景分析"></a>2.8 适用场景分析</h2><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。</p>
<p>AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</p>
<h1 id="三、一些关键类"><a href="#三、一些关键类" class="headerlink" title="三、一些关键类"></a>三、一些关键类</h1><h2 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h2><p>Netty 建立服务端的辅助类。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>频道、通道的意思。</p>
<p>是传入（入站）或者传出（出站）数据的载体。</p>
<p>可以被打开或者被关闭，连接或者断开连接。</p>
<p>在内部会为每个 Channel 分配一个 EventLoop，用以处理所有事件。</p>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><h2 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><p>是一组 EventLoop</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><h2 id="ChannelHandle"><a href="#ChannelHandle" class="headerlink" title="ChannelHandle"></a>ChannelHandle</h2><p>通道处理者，是所有处理入站和出站数据的应用程序逻辑的容器。</p>
<h3 id="ChannelHandlerAdapter"><a href="#ChannelHandlerAdapter" class="headerlink" title="ChannelHandlerAdapter"></a>ChannelHandlerAdapter</h3><h3 id="ChannelInboundHandlerAdapter"><a href="#ChannelInboundHandlerAdapter" class="headerlink" title="ChannelInboundHandlerAdapter"></a>ChannelInboundHandlerAdapter</h3><p>Netty 接收数据 Handler 处理器。</p>
<p></br></br></br></br></p>


            <!-- Tags -->
            


<div class="tags">
    <a href="/tags/Java/">Java</a> <a href="/tags/Netty/">Netty</a>
</div>



            <!-- Comments -->
            <div>
                




            </div>
        </div><!-- end content -->
    </section>
</section><!-- end main -->

<!-- After footer scripts -->

<!-- jQuery -->

<script src="/js/jquery.js"></script>


<!-- Custom Code -->

<script src="/js/main.js"></script>


<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>